# Итератор (iterator)

## Что такое итератор?

> Итератор представляет собой объект перечислитель, который для данного объекта выдает следующий элемент, либо бросает исключение, если элементов больше нет.

Итератор Python, неявно реализован в таких конструкциях, как циклы for, comprehension’ах и генераторах Python. Функции iter() и next() как раз и образуют протокол итератора.
Если мы можем получить итератор от объекта в Python, значит он итерабельный.

Основное их назначение – это упрощение навигации по элементам объекта, который, как правило, представляет собой некоторую коллекцию (список, словарь и т.п.).

## Где используется итератор?

> Основное место использования итераторов – это цикл for.

Если вы перебираете элементы в некотором списке или символы в строке с помощью цикла for, то ,фактически, это означает, что при каждой итерации цикла происходит обращение к итератору, содержащемуся в строке/списке, с требованием выдать следующий элемент, если элементов в объекте больше нет, то итератор генерирует исключение, обрабатываемое в рамках цикла for незаметно для пользователя.

Приведем несколько примеров, которые помогут лучше понять эту концепцию. Для начала выведем элементы произвольного списка на экран.

```python
num_list = [1, 2, 3, 4, 5]
for i in num_list:
    print(i)
1
2
3
4
5
```

Как уже было сказано, объекты, элементы которых можно перебирать в цикле for, содержат в себе объект итератор, для того, чтобы его получить необходимо использовать функцию `iter()`, а для извлечения следующего элемента из итератора – функцию `next()`.

```python
itr = iter(num_list)
print(next(itr))
1
print(next(itr))
2
print(next(itr))
3
print(next(itr))
4
print(next(itr))
5
print(next(itr))
Traceback (most recent call last):
  File "<pyshell#12>", line 1, in <module>
    print(next(itr))
StopIteration
```

Как видно из приведенного выше примера вызов функции `next(itr)` каждый раз возвращает следующий элемент из списка, а когда эти элементы заканчиваются, генерируется исключение `StopIteration`.

## Как написать собственный итератор?

Если нужно обойти элементы внутри объекта вашего собственного класса, необходимо построить свой итератор. Создадим класс, объект которого будет итератором, выдающим определенное количество единиц, которое пользователь задает при создании объекта. Такой класс будет содержать конструктор(`__init__`), принимающий на вход количество единиц и метод `next()`, без него экземпляры данного класса не будут итераторами.

```python
class SimpleIterator:
    def __init__(self, limit):
        self.limit = limit
        self.counter = 0

    def __next__(self):
        if self.counter < self.limit:
            self.counter += 1
            return 1
        else:
            raise StopIteration

s_iter1 = SimpleIterator(3)
print(next(s_iter1))
print(next(s_iter1))
print(next(s_iter1))
print(next(s_iter1))
```

В нашем примере при четвертом вызове функции `next()` будет выброшено исключение `StopIteration`. Если мы хотим, чтобы с данным объектом можно было работать в цикле for, то в класс `SimpleIterator` нужно добавить метод `iter()`, который возвращает итератор, в данном случае этот метод должен возвращать `self`.

```python
class SimpleIterator:
    def __iter__(self):
        return self

    def __init__(self, limit):
        self.limit = limit
        self.counter = 0

    def __next__(self):
        if self.counter < self.limit:
            self.counter += 1
            return 1
        else:
            raise StopIteration

s_iter2 = SimpleIterator(5)
for i in s_iter2:
    print(i)
```